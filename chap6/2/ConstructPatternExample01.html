<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>第六章节-创建对象-构造函数模式</title>
  <script>
    // 构造函数模式
    function Person(name, age, job) {
      this.name = name;
      this.age = age;
      this.job = job;
      this.sayName = function() {
        console.log(this.name)
      }
    }
    var person = new Person("李白", 55, "诗人");
    // person.sayName();
    var person2 = new Person("张三", 66, "无业");
    // 与工厂模式不同的有以下几点：
    // 1.构造函数的名称是大写的这一点和OO语言中的类名很像，也是在写法上用于区分普通的构造函数（JS在语法上并没有进行限制）
    // 2.没有显示的创建对象
    // 3.直接将属性和方法赋值给了this对象
    // 4.没有retrun 返回语句
    // 与其它OO语言相当于class中的构造方法，别外JS中的Object和Array也是用类似的构造方法（可以这样理解）
    
    // 在前面的例子中，person和person2都保存着一个不同的实例，这两个对象都有一个相同的构造函数（constructor）,该属性
    // 指向Person,如下：
    // console.log(person.constructor === person2.constructor) // true
    // console.log(person.constructor === Person) // true
    // 对象和construct最初是用来标识对象类型的，但是，提到对象类型检测还是用 instanceof 靠谱点
    console.log(person instanceof Person) // true
    console.log(person instanceof Object) // true
    console.log(person2 instanceof Person) // true
    console.log(person2 instanceof Object) // true
  </script>
</head>
<body>
  
</body>
</html>